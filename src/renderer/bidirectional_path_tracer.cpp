#include "fluid/renderer/bidirectional_path_tracer.h"

/// \file
/// Implementation of the bidirectional path tracer.

#include <random>

#include "fluid/math/warping.h"

namespace fluid::renderer {
	/// A version of \ref _pdf_to_solid_angle() that accepts a normalized direction and the squared distance between
	/// the two points.
	double _pdf_to_solid_angle_norm_diff(
		double pdf_source, vec3d source, vec3d norm_diff, double squared_length, vec3d hit_normal
	) {
		// TODO no handling of infinite light sources here
		// TODO no handling of media here
		pdf_source *= std::abs(vec_ops::dot(hit_normal, norm_diff));
		return pdf_source / squared_length;
	}
	/// Converts the probability density function of a outgoing ray direction into that expressed in solid angles.
	double _pdf_to_solid_angle(double pdf_source, vec3d source, vec3d hit, vec3d hit_normal) {
		vec3d diff = hit - source;
		double sqr_len = diff.squared_length();
		return _pdf_to_solid_angle_norm_diff(pdf_source, source, diff / std::sqrt(sqr_len), sqr_len, hit_normal);
	}

	/// Stores information about an intersection.
	struct _vertex {
		bsdf surface_bsdf; ///< BSDF of the surface.
		rmat3d tangent; ///< Matrix used to convert directions from world space to tangent space.
		spectrum attenuation; ///< The attenuation of light along the path.
		vec3d
			incoming_ray_dir_tangent, ///< Normalized negative direction of the incoming ray in tangent space.
			position, ///< The position of this vertex.
			geometric_normal; ///< The geometric normal.
		vec2d uv; ///< The UV at this position.
		double
			/// The probability density function of this vertex being generated by the previous vertex, in solid
			/// angles.
			pdf_forward = 0.0,
			/// The probability density function of this vertex being generated by the next vertex, in solid angles.
			pdf_reverse = 0.0;
		const primitive *prim = nullptr; ///< The intersected primitive.
		bool is_delta = false; ///< Indicates whether \ref surface_bsdf is a delta material.

		/// Returns the probability densitu function of the \ref _vertex \p next being sampled by this \ref _vertex
		/// in solid angles.
		double pdf_from_to(const _vertex &prev, const _vertex &next) const {
			vec3d
				in_norm = (prev.position - position).normalized_unchecked(),
				out_norm = next.position - position;
			double sqr_out_len = out_norm.squared_length();
			out_norm /= std::sqrt(sqr_out_len); // actually normalize out_norm
			double pdf = surface_bsdf.pdf(in_norm, out_norm);
			return _pdf_to_solid_angle_norm_diff(pdf, position, out_norm, sqr_out_len, next.geometric_normal);
		}
	};

	/// Traces a path given the initial ray and the maximum number of bounces.
	///
	/// \param out The output array. It is assumed that this already contains the initial vertex.
	/// \param sc The scene.
	/// \param max_bounces The maximum number of bounces.
	/// \param r The input ray. Its direction is assumed to be normalized.
	/// \param pdf The probability density function of the direction of the initial ray.
	/// \param rnd The random number generator.
	void _trace_path(
		std::vector<_vertex> &out, const scene &sc, std::size_t max_bounces, ray r, double pdf,
		double ray_offset, pcg32 &rnd
	) {
		std::uniform_real_distribution<double> dist(0.0, 1.0);
		double prev_pdf = pdf;
		spectrum attenuation = out.back().attenuation;
		for (std::size_t i = 0; i < max_bounces; ++i) {
			// find intersection
			auto [prim, hit, isect] = sc.ray_cast(r);
			if (!prim) { // no intersection
				break;
			}
			vec3d incoming_direction_tangent = isect.tangent * -r.direction;
			// new vertex
			_vertex &vertex = out.emplace_back();
			vertex.surface_bsdf = isect.surface_bsdf;
			vertex.tangent = isect.tangent;
			vertex.attenuation = attenuation;
			vertex.incoming_ray_dir_tangent = incoming_direction_tangent;
			vertex.position = isect.intersection;
			vertex.geometric_normal = isect.geometric_normal;
			vertex.uv = isect.uv;
			vertex.prim = prim;
			vertex.is_delta = isect.surface_bsdf.is_delta();
			// previous vertex, obtained here since emplace_back() may invalidate references
			_vertex &prev_vert = out[out.size() - 2];
			// sample bsdf for new ray
			bsdfs::outgoing_ray_sample sample = vertex.surface_bsdf.sample_f(
				incoming_direction_tangent, vec2d(dist(rnd), dist(rnd))
			);
			attenuation =
				modulate(attenuation, sample.reflectance) *
				(std::abs(sample.norm_out_direction_tangent.y) / sample.pdf);
			// calculate pdf
			if (vertex.is_delta) {
				vertex.pdf_forward = prev_vert.pdf_reverse = 0.0;
			} else {
				vertex.pdf_forward = _pdf_to_solid_angle(
					prev_pdf, prev_vert.position, vertex.position, isect.geometric_normal
				);
				double reverse_pdf = isect.surface_bsdf.pdf(
					sample.norm_out_direction_tangent, incoming_direction_tangent
				);
				prev_vert.pdf_reverse = _pdf_to_solid_angle(
					reverse_pdf, isect.intersection, prev_vert.position, prev_vert.geometric_normal
				);
			}
			// update
			r = isect.spawn_ray(sample.norm_out_direction_tangent, ray_offset);
		}
	}

	/// Scoped assignment.
	template <typename T> struct _scoped_assignment {
	public:
		/// Creates an empty object.
		_scoped_assignment() = default;
		/// Assigns the value to the target.
		_scoped_assignment(T &target, T value) : _old_value(std::move(target)), _target(&target) {
			target = std::move(value);
		}
		/// No copy construction.
		_scoped_assignment(const _scoped_assignment&) = delete;
		/// Move constructor.
		_scoped_assignment(_scoped_assignment &&src) : _old_value(std::move(src._old_value)), _target(src._target) {
			src._target = nullptr;
		}
		/// No copy assignment.
		_scoped_assignment &operator=(const _scoped_assignment&) = delete;
		/// Move assignment.
		_scoped_assignment &operator=(_scoped_assignment &&src) {
			reset();
			_old_value = std::move(src._old_value);
			_target = src._target;
			src._target = nullptr;
			return *this;
		}
		/// Destructor, calls \ref reset().
		~_scoped_assignment() {
			reset();
		}

		/// Manually resets this struct and the target value.
		void reset() {
			if (_target) {
				*_target = std::move(_old_value);
			}
		}
	private:
		T _old_value; ///< The old value.
		T *_target = nullptr; ///< The target.
	};
	/// Shorthand for creating \ref _scoped_assignment objects.
	template <typename T> [[nodiscard]] _scoped_assignment<T> _scoped_assign_to(T &target, T value) {
		return _scoped_assignment<T>(target, std::move(value));
	}

	/// Returns multiple importance sampling weight of the given path..
	double _mis_weight(
		std::vector<_vertex> &cam_path, std::vector<_vertex> &light_path,
		std::size_t cam_id, std::size_t light_id
	) {
		_vertex
			&cam_vert = cam_path[cam_id],
			&prev_cam_vert = cam_path[cam_id - 1],
			&light_vert = light_path[light_id],
			*prev_light_vert = light_id > 0 ? &light_path[light_id - 1] : nullptr;
		auto
			sa_cam_vert_pdf_rev = _scoped_assign_to(
				cam_vert.pdf_reverse, light_vert.pdf_from_to(*prev_light_vert, cam_vert)
			),
			sa_prev_cam_vert_pdf_rev = _scoped_assign_to(
				prev_cam_vert.pdf_reverse, cam_vert.pdf_from_to(light_vert, prev_cam_vert)
			),
			sa_light_vert_pdf_rev = _scoped_assign_to(
				light_vert.pdf_reverse, cam_vert.pdf_from_to(prev_cam_vert, light_vert)
			);
		double sum_ri = 0.0;
		// camera subpath
		double ri = 1.0;

		return 1.0;
	}

	spectrum bidirectional_path_tracer::incoming_light(const scene &sc, const ray &r, pcg32 &random) const {
		std::size_t num_lights = sc.get_lights().size();
		if (num_lights == 0) {
			return spectrum();
		}
		std::uniform_real_distribution<double> dist(0.0, 1.0);

		// normalize camera ray direction
		ray cam_ray = r;
		cam_ray.direction = cam_ray.direction.normalized_unchecked();
		// sample light ray
		std::uniform_int_distribution<std::size_t> light_dist(0, num_lights - 1);
		const primitive *light = sc.get_lights()[light_dist(random)];
		primitives::surface_sample surf_sample = light->sample_surface(vec2d(dist(random), dist(random)));
		vec2d light_ray_dir_sample(dist(random), dist(random));
		// only purely diffuse light sources are supported
		vec3d light_ray_dir_tangent = warping::unit_hemisphere_from_unit_square(light_ray_dir_sample);
		double light_ray_dir_pdf = warping::pdf_unit_hemisphere_from_unit_square(light_ray_dir_sample);
		rmat3d light_tangent = compute_arbitrary_tangent_space(surf_sample.geometric_normal);
		ray light_ray = intersection_info::spawn_ray_from(
			surf_sample.position, light_tangent.transposed() * light_ray_dir_tangent,
			surf_sample.geometric_normal, ray_offset
		);

		// trace camera path
		std::vector<_vertex> cam_path;
		{
			_vertex &cam_vert = cam_path.emplace_back();
			cam_vert.attenuation = spectrum::identity;
			cam_vert.position = r.origin;
		}
		_trace_path(cam_path, sc, max_camera_bounces, cam_ray, 1.0, ray_offset, random); // TODO camera pdf?
		// trace light path
		std::vector<_vertex> light_path;
		{
			_vertex &light_vert = light_path.emplace_back();
			light_vert.attenuation =
				light->entity->mat.emission.get_value(surf_sample.uv) *
				vec_ops::dot(surf_sample.geometric_normal, light_ray.direction) *
				static_cast<double>(num_lights) /
				(light_ray_dir_pdf * surf_sample.pdf);
			light_vert.tangent = compute_arbitrary_tangent_space(surf_sample.geometric_normal);
			light_vert.position = surf_sample.position;
			light_vert.geometric_normal = surf_sample.geometric_normal;
			light_vert.uv = surf_sample.uv;
			light_vert.prim = light;
		}
		_trace_path(light_path, sc, max_light_bounces, light_ray, light_ray_dir_pdf, ray_offset, random);

		spectrum result;
		std::size_t count = 0;
		// connect light rays
		for (std::size_t ci = 1; ci < cam_path.size(); ++ci) {
			// TODO sample the light
			_vertex &cam_vert = cam_path[ci];
			// account for direct light hits
			if (!cam_vert.prim->entity->mat.emission.modulation.near_zero()) {
				result += modulate(cam_vert.attenuation, cam_vert.prim->entity->mat.emission.get_value(cam_vert.uv));
			}
			if (!cam_vert.is_delta) {
				for (std::size_t li = 1; li < light_path.size(); ++li) {
					_vertex &light_vert = light_path[li];
					if (!light_vert.is_delta) {
						spectrum s = modulate(cam_vert.attenuation, light_vert.attenuation);
						vec3d cam_to_light_norm = (light_vert.position - cam_vert.position).normalized_unchecked();
						s = modulate(s, cam_vert.surface_bsdf.f(
							cam_vert.incoming_ray_dir_tangent, cam_vert.tangent * cam_to_light_norm
						));
						s = modulate(s, light_vert.surface_bsdf.f(
							light_vert.incoming_ray_dir_tangent, light_vert.tangent * -cam_to_light_norm
						));
						if (!s.near_zero()) {
							vec3d
								cam_test_pos = cam_vert.position + cam_vert.geometric_normal * ray_offset,
								light_test_pos = light_vert.position + light_vert.geometric_normal * ray_offset;
							if (sc.test_visibility(cam_test_pos, light_test_pos)) {
								// calculate G term
								vec3d diff = cam_vert.position - light_vert.position;
								double g = 1.0 / diff.squared_length();
								diff *= std::sqrt(g);
								g *= std::abs(vec_ops::dot(diff, cam_vert.geometric_normal));
								g *= std::abs(vec_ops::dot(diff, light_vert.geometric_normal));
								// multiply & accumulate
								s *= g;
								result += s;
							}
						}
					}
				}
			}
		}
		return result;
	}
}
